1. 等待/通知机制的实现：1）wait()方法的作用是使当前执行代码的线程进行等待，是一个Object类的方法，用来将当前线程置入预执行队列中，并且在wait()所在的代码出停止执行，知道接收到通知或者中断为止。在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在同步方法或者同步快中调用wait()方法。在执行完wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。如果调用wait()时没有持有适当的锁，则会抛出异常。2) notify()也要在同步方法或者同步快中调用，在调用前，线程必须获得该对象的对象级别锁。如果调用notify()时没有持有适当的锁，也会抛出IllegalMonitorStateException。该方法用来通知哪些可能等待该对象的对象锁的其他进程，如果多个进程等待，则有线程规划器随机挑选出其中一个呈wait状态的线程，当前线程不会马上释放该对象锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的wait线程执行完毕后，它会释放掉该对象锁，此时若果该对象没有再次使用notify语句，几遍该对象已经是空想状态，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，知道这个对象发出一个notify或者notifyALL。
2. 通过调用wait()方法可以使处于临界区内的线程进入等待状态，同时释放被同步的对象锁。notify()操作可以唤醒一个因调用了wait()操作而处于阻塞状态中的线程，使其进入就绪状态。被唤醒的线程视图重新获得临界区的控制权，也就是锁，并继续执行临界区内wait()之后的代码。如果发出notify时没有处于阻塞状态中的线程，那么该命令会被忽略。
3. ![](https://i.imgur.com/2tFoEdM.png) 1）新建一个线程对象后，在调用它的start()方法，系统会为此线程分配CPU资源，使其处于Runnable(可运行)状态，这是一个准备状态。如果线程抢占到CPU资源，此线程就处于Running(运行)状态。2) Runnable状态和Running状态可相互切换，若线程在运行一段时间后，有其他更高优先级的线程抢占了CPU资源，线程就进入Runnable状态。有以下5中情况：(1).调用sleep()方法后经过的时间超过了指定的休眠时间。(2).线程调用的阻塞IO已经返回，阻塞方法执行完毕。(3).线程成功获得了视图同步的监视器。(4).线程正在等待某个通知，其他线程发出了通知。(5).处于挂起状态的线程调用了resume()恢复方法。3) Blocked阻塞，出现阻塞大体为以下5种：(1).线程调用sleep方法，主动放弃占用的处理器资源。(2).线程调用了阻塞式的IO方法，在该方法返回前，该线程被阻塞。(3).线程试图获得一个同步监视器，但该监视器正在被其他线程所持有。(4).线程正在等待某个通知。(5).线程调用了suspend方法将该线程挂起，此方法易造成死锁，应避免使用。4）run()方法运行结束后进入销毁，整个线程执行完毕。
4. 每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列中是将要获得锁的线程，阻塞队列是被阻塞的线程。当线程被唤醒后，才会进入就绪队列，等待CPU调度；当一个线程被wait()后就会进入阻塞队列，等待下次被唤醒。
5. 通过管道进行线程间通信：管道流是一种特殊的流，用于在不同线程间直接传送数据，一个线程发送数据到管道，另一个线程从输入管道中读取数据。通过使用管道，实现不同线程间的通信。(PipeInputStream、PipeOutputStream、PipeReader、PipeWriter)，有字节流和字符流两种方式。
6. join()方法：使所属的线程对象X正常运行run()方法中的任务，而是当前线程Z进行无限期的阻塞，等待线程X销毁后在继续执行线程Z后面的代码。join方法具有使线程排队的作用，有些雷士同步的运行效果，与synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键是使用的是"对象监视器"原理作为同步。join(long)与sleep(long)的区别：jion内部wait方法执行完后，当前线程的锁被释放，其他线程可以调用次线程中的同步方法了，sleep方法不会释放锁。