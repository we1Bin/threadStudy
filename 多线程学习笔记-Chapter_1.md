1. 线程被调用的时机是随机的。
2. 实现方法：继承Thread类或者实现Runnable接口的方式，如果继承Thread类无法扩展，因为Java是单根继承；可以实现Runnable接口的方式。
3. 非线程安全：指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。
4. 停止线程：1）使用退出标志，使线程正常退出，也就是当run()方法完成后线程终止。 2）使用stop()方法强行终止线程，不推荐使用这个方法，因为stop()和suspend()以及resume()一样，可能会产生不可预料的结果。 3）使用interrupt()方法中断线程。建议使用“抛异常”的方法来实现线程的停止，因为在catch块还可以将异常向上抛，使得线程停止的时间得以传播。
5. stop()会对锁定的对象进行了“解锁”，释放锁将会给数据造成不一致性的结果。如果出现这样的情况，程序处理的数据就有可能遭到破坏，最终导致程序执行的流程错误。
6. suspend()暂停、resume()恢复方法缺点：1）独占，极易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象。2）不同步，容易出现因为线程的暂停而导致数据不同步的情况。
7. yield()方法的作用是放弃当前CPU资源，将他让给其他的任务去占用CPU执行时间，但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。
8. 线程的优先级：设置线程的优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。1）优先级别分为1~10这10个等级，如果小于1或者大于10，则会抛出异常。2）线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。3）高优先级的线程总是大部分先执行完，但并不代表高优先级的线程全部先执行完。CPU会尽量将执行资源让给优先级比较高的线程。4）优先级具有随机性，也就是说优先级高的线程不一定每一次都先执行完。
9. 守护线程(Daemon Thread)：Java线程中有两种线程，一种是用户线程，另一种是守护线程。任何一个守护线程都是整个JVN中所有非守护线程的“保姆”，只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作，只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。典型的守护线程就是垃圾回收线程（GC）。将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 2）在Daemon线程中产生的新线程也是Daemon的。 3）守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。
